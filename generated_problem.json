{
    "title": "MelonHiker's Graph Quest",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "description": "MelonHiker's favorite game is c++ and playing every day. He also enjoys exploring the intricate network of a hidden underground cave system. The cave system consists of $n$ chambers connected by bidirectional tunnels. Each tunnel has a specific length. MelonHiker starts at chamber 1 and wants to reach chamber $n$. However, he wants to minimize the maximum length of the tunnels in a single path from chamber 1 to chamber $n$ that gives the shortest path.\n\nMore specifically, given a value $x$, let's consider a journey to be valid only if the length of every tunnel used does not exceed $x$. Then, let $f(x)$ denote the minimum number of tunnels used to reach chamber $n$ from chamber 1 when only tunnels with length no more than $x$ are considered. If no path exists for the given $x$, then $f(x)$ is infinity. You need to find the smallest value of $x$ that minimizes $f(x)$ among all valid paths.",
    "input_constraints": "The first line contains two integers $n$ and $m$ ($2 \\le n \\le 1000$, $1 \\le m \\le 20000$), representing the number of chambers and the number of tunnels.\nEach of the following $m$ lines contains three integers $u$, $v$, and $w$ ($1 \\le u, v \\le n$, $1 \\le w \\le 10^6$), representing a bidirectional tunnel between chambers $u$ and $v$ with a length of $w$. There can be multiple tunnels between the same two chambers.",
    "output_constraints": "Print a single real number, the minimum value of $x$ which gives the minimum tunnel path. Your answer will be considered correct if its absolute or relative error does not exceed $10^{-6}$.",
    "examples": [
        {
            "input": "4 5\n1 2 1\n1 3 2\n2 4 3\n3 4 4\n1 4 5",
            "output": "3.0000000000"
        },
        {
            "input": "5 6\n1 2 5\n1 3 2\n2 4 4\n3 5 6\n4 5 2\n1 5 8",
            "output": "4.0000000000"
        }
    ],
    "note": "In the first example, consider:\n- If $x=1$, there is only one tunnel connecting $1$ and $2$. It's not possible to reach chamber 4. So $f(1) = \\infty$.\n- If $x=2$, there are two paths: $1-2$ and $1-3$. It's not possible to reach chamber 4. So $f(2) = \\infty$.\n- If $x=3$, tunnels with length no more than 3 are $(1, 2), (1, 3), (2, 4)$. A possible path is $1-2-4$. So $f(3)=2$.\n- If $x=4$, tunnels with length no more than 4 are $(1, 2), (1, 3), (2, 4), (3, 4)$.  A possible path is $1-2-4$. So $f(4)=2$.\n- If $x=5$, we can either use $1-2-4$ or $1-4$. Both results in two edges. So $f(5) = 2$.\n\nThe optimal $x$ which yields the minimum number of tunnels is $3$.\n\nIn the second example,\n- if $x=2$ the path is $1-3$. It is not possible to reach chamber 5.\n- if $x=4$ we can use $1-2$ and $2-4$ which is not able to reach chamber 5.\n- if $x=5$ we can use $1-2$ or $1-3$ and then reach chamber 5. A path can be $1-2-4-5$. So $f(5) = 3$. But we also have a $1-3$ path. So $f(5) = 3$.\n- if $x=6$ we can use the path $1-3-5$. $f(6)=2$\n- if $x=8$ we can use the path $1-5$. $f(8)=1$\nThe smallest $x$ that minimizes path length is 4, as $f(x) = 2$ is minimized at $x=4$.",
    "solution_in_natural_language": "The core idea is to perform a binary search on the possible tunnel lengths (the 'x' values) and within each loop we calculate the function f(x).\n\n1.  **Collect all tunnel lengths:** Read the input and store all unique tunnel lengths in a sorted list. This list will be our search space for `x`.\n2.  **Binary Search:** Perform a binary search on the sorted list of tunnel lengths. For each `x` (midpoint during binary search):\n    *   **Filter Edges:** Create a subgraph of only tunnels that have a length less than or equal to `x`.\n    *   **BFS to find shortest path:** Use Breadth-First Search (BFS) on the filtered subgraph to find the minimum number of tunnels needed to reach chamber `n` from chamber 1.\n    *  If no path exists,  f(x) is infinity.\n    *   If a path exists,  f(x) becomes the length of shortest path.\n3. **Optimization**: Update search window based on f(x). If f(x) is not infinity and is equal or less than the minimal path already found, we will search the lower values, as we are trying to find the *smallest* `x`. Otherwise, if no path exists or the path length is longer than current min path length, we move to the upper values.\n4.  **Track Best `x`:** Keep track of the smallest `x` value that gives the minimum `f(x)` found so far. If multiple `x` values gives the same `f(x)`, keep the smallest value.\n5.  **Output:** Print the best `x` value found with the desired precision.",
    "time_complexity": "O(m log m)",
    "space_complexity": "O(m)",
    "difficulty": "1600-1800"
}