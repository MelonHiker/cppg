{
    "title": "Graph Transformation",
    "time_limit": "2 seconds",
    "memory_limit": "256 megabytes",
    "description": "You are given a graph with $$$n$$$ nodes and $$$m$$$ edges. Each edge has a label, which is a lowercase English letter. You are asked to transform this graph into a new graph following these rules. First, for each node, compute the string that is obtained by concatenating the labels of all edges incident to the node in lexicographical order of their labels. Let this string for node $$$i$$$ be $$$s_i$$$. Create a new graph with $$$n$$$ nodes. There will be an edge between node $$$u$$$ and $$$v$$$ in the new graph if and only if the string $$$s_u$$$ and $$$s_v$$$ are not equal and have the same length. If there is an edge between nodes $$$u$$$ and $$$v$$$ in the new graph, assign it a weight of 1. In the resulting new graph, find the size of the maximum matching.",
    "input_constraints": "$$$1 \\le n \\le 2 \\cdot 10^3$$$, $$$0 \\le m \\le 10^5$$$, $$$1 \\le u, v \\le n$$$, $$$u \\ne v$$$, $$$c$$$ is a lowercase English letter. There can be multiple edges between the same pair of nodes, and self-loops are not allowed.",
    "output_constraints": "Print a single integer, the size of the maximum matching in the new graph.",
    "examples": [
        {
            "input": "4 5\n1 2 a\n1 3 b\n2 3 c\n3 4 a\n2 4 b",
            "output": "1"
        },
        {
            "input": "5 6\n1 2 a\n1 3 b\n2 3 a\n2 4 c\n3 5 a\n4 5 b",
            "output": "2"
        }
    ],
    "note": "In the first example,\n- Node 1 has edges: (1, 2, 'a'), (1, 3, 'b'). So, s_1 = \"ab\".\n- Node 2 has edges: (2, 1, 'a'), (2, 3, 'c'), (2, 4, 'b'). So, s_2 = \"abc\".\n- Node 3 has edges: (3, 1, 'b'), (3, 2, 'c'), (3, 4, 'a'). So, s_3 = \"abc\".\n- Node 4 has edges: (4, 3, 'a'), (4, 2, 'b'). So, s_4 = \"ab\".\nThe new graph has edges between nodes:\n- 1 and 4 (because s_1=\"ab\" and s_4=\"ab\" have the same length and are not equal).\n- 2 and 3 (because s_2=\"abc\" and s_3=\"abc\" have the same length and are not equal).\nThe maximum matching can be formed by selecting either the edge (1,4) or the edge (2,3). Therefore, the maximum matching size is 1.\n\nIn the second example,\n- Node 1 has edges: (1, 2, 'a'), (1, 3, 'b'). So, s_1 = \"ab\".\n- Node 2 has edges: (2, 1, 'a'), (2, 3, 'a'), (2, 4, 'c'). So, s_2 = \"aac\".\n- Node 3 has edges: (3, 1, 'b'), (3, 2, 'a'), (3, 5, 'a'). So, s_3 = \"aab\".\n- Node 4 has edges: (4, 2, 'c'), (4, 5, 'b'). So, s_4 = \"bc\".\n- Node 5 has edges: (5, 3, 'a'), (5, 4, 'b'). So, s_5 = \"ab\".\nThe new graph has edges between nodes:\n- 1 and 5 (s_1 and s_5 have length 2)\n- 2 and 3 (s_2 and s_3 have length 3)\n- 1,5 and 4 (s_1,s_5,s_4 have length 2).\n- 1 and 4, 4 and 5.\nThe new graph has edges (1,5), (1,4) and (4,5). The maximum matching size is 2, choosing (1,5) and (2,3) for example.",
    "solution_in_natural_language": "1. Read the input graph and store the edge labels for each node. Use an adjacency list where each node stores a list of characters.\n2. For each node, sort its incident edge labels lexicographically, concatenate the labels to create a string and store the string.\n3. Construct the new graph using an adjacency matrix. An edge exists between two nodes if their corresponding strings are of the same length and not equal.\n4. Perform iterative Depth First Search (DFS) to find a maximum matching. Start from every node and try to find an augmenting path. The augmenting path starts at an unmatched node, alternates between unmatched and matched edges, and ends in an unmatched node. If found, update the matching. \n5. The size of the maximum matching is the number of matching edges.",
    "time_complexity": "O(n^3)",
    "space_complexity": "O(n^2)",
    "difficulty": "1900"
}